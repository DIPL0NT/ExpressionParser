//TODO REWRITE CONSIDERING THAT args IS A ExpressionTreeNode_List POINTER
ExpressionTreeNode *alloc_ExpressionTreeNode(ExpressionTreeNode *root,ExpressionElement el){
	ExpressionTreeNode *newNode = (ExpressionTreeNode*) malloc(sizeof(ExpressionTreeNode));
	//if (!newNode) ...
	newNode->root = root;
	newNode->element = el;
	if (el.type==OPERATOR ){
		if (((Operator*)el.data)->arity>0){
			//newNode->args = (ExpressionTreeNode**) malloc( ((Operator*)el.data)->arity * sizeof(ExpressionTreeNode*) );
			//if (!newNode->args) ...
			for (int i=0;i<((Operator*)el.data)->arity;i++){
				//newNode->args[i] = NULL;
			}
		}
		else{
			newNode->args = NULL;
		}
	}
	else if (el.type==OPERAND){
		newNode->args = NULL;
	}
	//it should never happen that el is of type NULLTERM, OPENPAR, CLOSEPAR, COMMA

	return newNode;
}

//TODO REWRITE CONSIDERING THAT args IS A ExpressionTreeNode_List POINTER
void free_ExpressionTreeNode(ExpressionTreeNode* node){
	if (node->element.type==OPERAND){
		release_ExpressionElement(node->element);
		//node->args should be NULL
		free(node);
		return;
	}
	else if (node->element.type==OPERATOR){
		for (int i=0;i<((Operator*)node->element.data)->arity;i++){
			//free_ExpressionTreeNode(node->args[i]);
		}
		release_ExpressionElement(node->element);
		if (node->args) free(node->args); //need to check that it isn't NULL for operators with arity 0
		free(node);
		return;
	}
	//it should never happen that el is of type NULLTERM, OPENPAR, CLOSEPAR, COMMA

	return;
}

//SPEZZONE PRESO da get_next_ExpressionElement_from_ExpressionString PRIMA DI RISCRITTURA PER CONSIDERARE il WHITESPACE
while (isOperandChar(es->str[i])) i++;
if (i!=es->index){ //the character encountered was the beginning of a operand token
	char tmp = es->str[i];
	es->str[i] = '\0';
	el.type = OPERAND;
	el.data = parseOperandStringFormatToVoidPtr(es->str+es->index);
	es->str[i] = tmp;
	es->index = i;
	return el;
}

while ( !isOperandChar(es->str[i]) &&es->str[i]!='(' &&es->str[i]!=')' &&es->str[i]!=',' &&es->str[i]!='\0') i++;
	
char tmp = es->str[i];
es->str[i] = '\0';
for (int j=0;j<NUMofOPERATORS;j++){
	if (!strcmp(es->str+es->index,operators[j]->symbol)){
		el.type = OPERATOR;
		el.data = (void*) operators[j];
		es->str[i] = tmp;
		es->index = i;
		return el;
	}
}



//SPEZZONE DA fill_INCOMPLETE_ExpressionTreeNode
case (OPENPAR):{
            if (currentNode->type==OPERATOR_NODE){ //check compatibility with current op
                if (currentOp->fix==PREFIX){
                    if (currentNode->args.count /*>*/= currentOp->arity){
                        printf("ERROR while parsing token number %d (argument count > \033[36m%d\033[0m = operator \"\033[36m%s\033[0m\"'s arity\n",vec->index-1,currentOp->arity,currentOp->symbol);
                        error = 2;
                        return error;
                    }
                }
                if (currentOp->fix==INFIX){
                    if (currentNode->args.count != 1){
                        printf("ERROR while parsing token number %d (INFIX operator \"\033[36m%s\033[0m\" must have exactely one operand before it)\n",vec->index-1,currentOp->symbol);
                        error = 2;
                        return error;
                    }
                }
                if (currentOp->fix==POSTFIX){
                    /* CHECKS on POSTFIX OPERATORS ARE DONE AS SOON AS the OPERATOR is ENCOUNTERED
                    if (currentNode->args.count != currentOp->arity){
                        printf("ERROR while parsing token number %d (argument count < \033[36m%d\033[0m) = operator \"\033[36m%s\033[0m\"'s arity\n",vec->index-1,currentOp->arity,currentOp->symbol);
                        error = 2;
                        return error;
                    }
                    */
                }
            }



//SPEZZONE DA fill_INCOMPLETE_ExpressionTreeNode
case(OPERATOR):{
			if (currentNode->type==INCOMPLETE){
                currentOp = (const Operator*)currentToken.data;
                if (currentOp->fix==INFIX){
                    if (currentNode->args.count!=1){
                        printf("ERROR while parsing token number %d (INFIX operator \"\033[36m%s\033[0m\" must have exactely one operand before it)\n",vec->index-1,currentOp->symbol);
                        error = 2;
                        return error;
                    }
                }
                if (currentOp->fix==POSTFIX){
                    if (currentNode->args.count < currentOp->arity){
                        printf("ERROR while parsing token number %d (argument count < \033[36m%d\033[0m) = operator \"\033[36m%s\033[0m\"'s arity\n",vec->index-1,currentOp->arity,currentOp->symbol);
                        error = 2;
                        return error;
                    }
                }

                ExpressionTreeNode *newNode = alloc_ExpressionTreeNode(currentNode,OPERATOR_NODE,currentToken);
                if (currentOp->fix==INFIX){
                    addToTail_ExpressionTreeNode_List(&newNode->args,removeTail_ExpressionTreeNode_List(&currentNode->args));
                }
                if (currentOp->fix==POSTFIX){
                    for (int i=0;i<currentOp->arity;i++){
                        addToHead_ExpressionTreeNode_List(&newNode->args,removeTail_ExpressionTreeNode_List(&currentNode->args));
                    }
                }

                addToTail_ExpressionTreeNode_List(&currentNode->args,newNode);
                currentNode = newNode;
            }
            else if (currentNode->type==OPERATOR_NODE){
                const Operator* newOp = (const Operator*)currentToken.data;
                if ( newOp->precedence > currentOp->precedence ){
                    if (newOp->fix==INFIX){
                        if (currentNode->args.count!=1){
                            printf("ERROR while parsing token number %d (INFIX operator \"\033[36m%s\033[0m\" must have exactely one operand before it)\n",vec->index-1,newOp->symbol);
                            error = 2;
                            return error;
                        }
                    }
                    if (newOp->fix==POSTFIX){ //precedence doesn't really make sense in this case anyway
                        while (currentNode->type!=LIST_NODE){
                            currentNode = currentNode->root;
                        }
                        if (currentNode->args.count < newOp->arity){
                            printf("ERROR while parsing token number %d (argument count < \033[36m%d\033[0m) = operator \"\033[36m%s\033[0m\"'s arity\n",vec->index-1,newOp->arity,newOp->symbol);
                            error = 2;
                            return error;
                        }
                    }

                    ExpressionTreeNode *newNode = alloc_ExpressionTreeNode(currentNode,OPERATOR_NODE,currentToken);
                    if (newOp->fix==INFIX){
                        addToTail_ExpressionTreeNode_List(&newNode->args,removeTail_ExpressionTreeNode_List(&currentNode->args));
                    }
                    if (newOp->fix==POSTFIX){
                        for (int i=0;i<newOp->arity;i++){
                            addToHead_ExpressionTreeNode_List(&newNode->args,removeTail_ExpressionTreeNode_List(&currentNode->args));
                        }
                    }

                    addToTail_ExpressionTreeNode_List(&currentNode->args,newNode);
                    if (newOp->fix!=POSTFIX){
                        currentNode = newNode;
                        currentOp = newOp;
                    }
                }
                else{ // newOp->precedence <= currentOp->precedence
                    while (currentNode->root->type!=LIST_NODE && newOp->precedence<=currentOp->precedence){
                        if (currentNode->args.count!=currentOp->arity){
                            printf("ERROR while parsing (argument count < \033[36m%d\033[0m) = operator \"\033[36m%s\033[0m\"'s arity\n",newOp->arity,newOp->symbol);
                            error = 2;
                            return error;
                        }

                        currentNode = currentNode->root;
                        currentOp = (Operator*)currentNode->token.data;
                    }
                    //if newOp postfix
                    //else
                    
                }
            }
            //there should be no other else
            break;
}


