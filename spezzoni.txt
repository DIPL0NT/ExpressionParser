//TODO REWRITE CONSIDERING THAT args IS A ExpressionTreeNode_List POINTER
ExpressionTreeNode *alloc_ExpressionTreeNode(ExpressionTreeNode *root,ExpressionElement el){
	ExpressionTreeNode *newNode = (ExpressionTreeNode*) malloc(sizeof(ExpressionTreeNode));
	//if (!newNode) ...
	newNode->root = root;
	newNode->element = el;
	if (el.type==OPERATOR ){
		if (((Operator*)el.data)->arity>0){
			//newNode->args = (ExpressionTreeNode**) malloc( ((Operator*)el.data)->arity * sizeof(ExpressionTreeNode*) );
			//if (!newNode->args) ...
			for (int i=0;i<((Operator*)el.data)->arity;i++){
				//newNode->args[i] = NULL;
			}
		}
		else{
			newNode->args = NULL;
		}
	}
	else if (el.type==OPERAND){
		newNode->args = NULL;
	}
	//it should never happen that el is of type NULLTERM, OPENPAR, CLOSEPAR, COMMA

	return newNode;
}

//TODO REWRITE CONSIDERING THAT args IS A ExpressionTreeNode_List POINTER
void free_ExpressionTreeNode(ExpressionTreeNode* node){
	if (node->element.type==OPERAND){
		release_ExpressionElement(node->element);
		//node->args should be NULL
		free(node);
		return;
	}
	else if (node->element.type==OPERATOR){
		for (int i=0;i<((Operator*)node->element.data)->arity;i++){
			//free_ExpressionTreeNode(node->args[i]);
		}
		release_ExpressionElement(node->element);
		if (node->args) free(node->args); //need to check that it isn't NULL for operators with arity 0
		free(node);
		return;
	}
	//it should never happen that el is of type NULLTERM, OPENPAR, CLOSEPAR, COMMA

	return;
}

//SPEZZONE PRESO da get_next_ExpressionElement_from_ExpressionString PRIMA DI RISCRITTURA PER CONSIDERARE il WHITESPACE
while (isOperandChar(es->str[i])) i++;
if (i!=es->index){ //the character encountered was the beginning of a operand token
	char tmp = es->str[i];
	es->str[i] = '\0';
	el.type = OPERAND;
	el.data = parseOperandStringFormatToVoidPtr(es->str+es->index);
	es->str[i] = tmp;
	es->index = i;
	return el;
}

while ( !isOperandChar(es->str[i]) &&es->str[i]!='(' &&es->str[i]!=')' &&es->str[i]!=',' &&es->str[i]!='\0') i++;
	
char tmp = es->str[i];
es->str[i] = '\0';
for (int j=0;j<NUMofOPERATORS;j++){
	if (!strcmp(es->str+es->index,operators[j]->symbol)){
		el.type = OPERATOR;
		el.data = (void*) operators[j];
		es->str[i] = tmp;
		es->index = i;
		return el;
	}
}






